Universal C Library: Array Construct

Copyright © 2019-2020 ARQADIUM LLC
All rights reserved.

§1. #UNI_ARRAY
---------------

Type-like shorthand for array structs of a given type. Be sure to declare it
using one of the DECL_* macros first.

Variables of this type have two properties, accessible by dot notation:
 1. val: the array itself, as a pointer to the given type
 2. sz: the size of the array, expressed as the number of elements allocated

§2. #UNI_ARRAYP
----------------

Like §1, but for arrays of pointer types. Necessary for token pasting to work.

§3. #UNI_DECL_ARR{_S,_P,_SP,}
------------------

Declare an array type of another type, in the type namespace (no prefixes). If
the ‘_S’ suffix is used, prepend a ‘struct’ keyword for the type. If the ‘_P’
suffix is used, make it a pointer to the type name. If ‘_SP’ is appended, make
it a pointer to the type and also prepend the ‘struct’ keyword. These variants
are needed to prevent token pasting from being broken by asterisks and spaces.
It is possible to use typedefs instead, but this choice is left up to the API
user as their types will need to be declared as such.

§4. #UNI_DECL_ARR_S
--------------------

Declare an array type of another struct type, in the struct namespace.

§5. STRUCT UNI_VEC
-------------------

Structure for keeping information about a vector.

This structure offers four member variables:
 1. sz: the occupied size of the vector array, in number of elements
 2. cap: the available memory of the vector array, in number of elements
 3. elem_sz: the size of a single element, in bytes
 4. data: a pointer to the vector array data

If sz > 0 and cap == 0, then the vector has been dwarfed as a slice. Reserve
operations cannot be performed on slices, and this includes calls to
uni_vec_reserve(). Also forbidden on slices are calls to uni_vec_emplace()
which either shift elements or cause reallocation: the only permitted
emplacements are 1:1, ergo the new data size is the same as the size of the
range provided. If a fully-fledged vector object is needed, uni_vec_dup() may
be used to copy the slice into a new object.

§6. UNI_VEC_INIT
-----------------

Initialise a new vector array object. This takes two arguments:
	0. The size of each element, in bytes
	1. The number of elements to reserve, initially

Requirements:
	- arg[0] must be greater than 0.

If successful, returns a valid ‘struct uni_vec’ object. If arg[1] was > 0,
then the memory pointed to by .data will be valid and properly sized. Upon
failure, .cap will be > 0 and .data will be NULL, signaling OoM error.

§7. UNI_VEC_INIT_EX
--------------------

Initialise a new vector array object with data already allocated, passing
future memory management responsibilities of the buffer to the uni_vec_*
functions. This takes three arguments:
	0. The size of each element, in bytes
	1. The number of elements in the buffer
	2. A pointer to the buffer; must be heap-allocated

Requirements:
	- arg[0] must be greater than 0.
	- arg[1] must be greater than 0.
	- The size of the memory pointed to by arg[2], in bytes, must be greater
		than or equal to ‘arg[1] * arg[0]’
	- arg[2] cannot be NULL.
	- arg[2] must point to a heap-allocated block apprehensible using C
		standard library memory management utilities (malloc(), free(), ...)

Returns a valid ‘struct uni_vec’ type.

§8. UNI_VEC_FINI
-----------------

Finalise a vector array object, freeing the memory within it. After this
operation, the object is invalid and should not be read from or written to.

Implicit requirements:
 -  arg[0] must be a valid object of ‘struct uni_vec’ type

§9. UNI_VEC_DUP
----------------

Duplicate a vector array object. The new object will have its own properties
and its own copy of the data payload. As this operation creates a new object,
it is useful for creating new, independent arrays from slices taken of other
arrays, so that it can be resized and emplaced into normally.

§10. UNI_VEC_RESERVE
---------------------

Reserve memory for a given number of elements. This takes the following
arguments:
	0. An object of ‘struct uni_vec’ type
	1. The number of additional elements’ worth of memory to reserve

Requirements:
	- arg[0] must not be a slice [note 1]

Implicit requirements:
	- arg[0] must be a valid object of ‘struct uni_vec’ type

§11. UNI_VEC_EMPLACE
---------------------

Emplace data from one vector array object into another. This takes the
following arguments:
	0. The destination vector
	1. The source vector (to be emplaced)
	2. A range of the destination vector to emplace into

The function will use these arguments to perform an elegant emplacement of the
source data into the destined vector. The range specifies a subset of the
destination vector where the source data will be inserted, with .lo marking
the beginning (inclusive) and .hi marking the end (exclusive). This range will
be overwritten with the new data, and if the range is smaller than the size of
the new data, additional elements will be inserted after the end of the range,
shifting the remaining elements over. If the range is larger, the elements
lacking replacements will be deleted, shifting the remaining ones back. If the
operation would overflow, uni_vec_reserve() is called under the hood to ensure
enough memory is available for the new vector.

Requirements:
	- The computed size of arg[2] (see UNI_SIZEOF_RANGE() in
		<unilib/geometry.h>) must be less than or equal to the size of
		the destination vector.
	- The destination vector must not be a slice [note 1]

Implicit requirements:
	- arg[0] must be a valid object of ‘struct uni_vec’ type.
	- arg[1] must be a valid object of ‘struct uni_vec’ type.
	- arg[2] must be a valid object of ‘struct rangep’ type.

§12. UNI_VEC_SLACKOFF
----------------------

This function ‘slacks off’ excess allocated memory, resizing the capacity to
be just large enough to contain the data present. It takes the following
arguments:
	0. Input vector array object to slim down.

Returns the vector with the new, minimum allocation.

Implicit requirements:
	- arg[0] must be a valid object of ‘struct uni_vec’ type.

§13. UNI_VEC_SLICE
-------------------

This function returns a ‘slice’ of a vector, given a range. It takes the
following arguments:
	0. The input vector, from which the slice is taken.
	1. Range of the input vector by which to delimit the slice.

Returns a vector array slice object of the input vector. The size of the
vector will be as large as the slice, while the capacity will be zero,
denoting its incapacity to be modified.

Requirements:
	- The range’s .hi must not exceed the .sz of the input vector.

Implicit requirements:
	- arg[0] must be a valid object of ‘struct uni_vec’ type.
	- arg[1] must be a valid object of ‘struct rangep’ type.
